COMPILER: (54 words)
---------

Defined in assembly core:

."

s"

s,      ( addr len -- ) compiles a string from RAM to Flash

Edefer

Rdefer

is

sliteral (C: addr len -- ) compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack

does>

find

findnfa

findnxt

:       ( -- ) (C: "<spaces>name" -- ) create a named entry in the dictionary. Terminated with ;

;       ( -- ) Immediate: finish colon defintion, compiles a RET(exit) and returns to interpret state 

:noname

[       ( --  ) Immediate: enter interpreter mode

]       ( --  ) enter compiler mode

[char]  ( -- c ) (C: "<space>name" -- ) Immediate: skip leading space delimites, place the first character of the word on the stack

,       ( n -- ) compile n into flash at DP (dictionary pointer), advances DP

dp+1    ( -- ) increment DP (dictionary pointer) by one

dp+     ( offset -- ) add offset to DP (dictionary pointer)

(create) ( --  ) (C: "<spaces>name" -- voc-link ) parse the input and create an vocabulary entry without XT and data field (PF)

header

latest  ( -- addr ) Immediate: Get flash program address of latest word being compiled.

nfa>lfa

nfa>xtf

wid

Defined in Forth Source:

>mark    ( -- start ) places current dictionary position for forward branch resolve

>resolve ( start -- ) resolve forward jump: compiles relative jump to resolve position at the start position which is on TOS 

<mark    ( -- dest ) place destination for backward branch

<resolve ( dest -- ) resolve backward branch: compiles relative jump to start position at the resolve position

if       ( f -- ) (C: -- orig ) start conditional branch: compiles zerosense, branch on not equal, and relative jump

?if      ( f -- f ) (C: -- orig ) start conditional branch: compiles dupzerosense, branch on not equal, and relative jump

else     (C: orig1 -- orig2 ) resolve the forward reference and place a new unresolved forward reference

then     ( -- ) (C: orig -- ) finish if: resolve forward reference

begin    ( -- ) (C: -- dest ) put the destination address for the backward branch

while    ( f -- ) (C: dest -- orig dest ) at runtime skip to after repeat if non-true: same as if. use repeat at end of while.

?while   ( f -- f ) (C: dest -- orig dest ) at runtime skip to after repeat if non-true: same as if. use repeat at end of while. does not consume flag.

repeat   ( --  ) (C: orig dest -- ) continue execution at dest, resolve orig

until    ( f -- ) (C: dest -- ) finish begin with conditional branch, leaves the loop if true flag at runtime

?until   ( f -- f ) (C: dest -- ) finish begin with conditional branch, leaves the loop if true flag at runtime. does not consume flag

again    ( -- ) (C: dest -- ) compile a jump back to dest

var      ( cchar -- ) create a dictionary entry for a variable and allocate 1 cell RAM

con      ( x -- ) (C: x "<spaces>name" -- ) create a constant in the dictionary
	example: 10 con myconstant -> create a word called "myconstant" that will put the value 10 on the top of the stack

user

recurse

immediate ( -- ) makes most recently defined word immediate : it will execute when in compile mode

create

\         ( -- ) start a comment. Text until end of line is ignored

(         ( "ccc<paren>" -- ) skip everything up to the closing bracket on the same line

)         ( -- ) marks end of comment

compile

cxt

[']

'

val

to

inline

lit



System: (24 words)
-------
Defined in assembly core:

exec ( xt -- ?? ) execute xt - calls address on TOS
up@  ( -- addr ) get user area pointer
up!  ( addr -- ) set user area pointer
defx ( addr -- n ) execute the defer fetch
nfa>lfa
state
>in
#tib
tib
refill-tib
source-tib
pad
dp
edp
here
allot
source
quit ( -- ) main loop of asforth. accept - interpret in an endless loop
pause ( -- ) Fetch pause vector and EXEC it. may make a context/task switch
cold ( -- ) start up amforth.
warm ( nx* -- ) (R: ny* -- ) initialize asforth further. EXECs turnkey operation and go to quit
defer!
defer@
ee-user

Interpreter: (6 words)
------------

interpret
recx
rec@
rec-num
rec-word
rec-unk



Parameter Stack: (17 words)
----------------
Defined in assembly core:

dup ( n -- n n ) inline: duplicate top of stack 

?dup ( n1 -- [ n1 n1 ] | 0) duplicate top of stack if non-zero

swap ( n1 n2 -- n2 n1) swaps the two top level stack cells

over ( x1 x2 -- x1 x2 x1 ) Place a copy of x1 on top of the stack

2over ( x1 x2 -- x1 x2 x1 x2 ) Place a copy of x1 and x2 on top of the stack

drop ( n -- ) drop the top of stack : inline

2drop ( n n -- ) drop top of stack and next on stack

nip ( n1 n2 -- n2) drop next on stack, one before top of stack

tuck ( n1 n2 -- n2 n1 n2) tuck TOS before NOS, same as SWAP OVER

flip ( n1 n2 n3 -- n3 n2 n1) exchange TOS and stack cell before NOS, same as SWAP ROT

rot ( n1 n2 n3 -- n2 n3 n1) rotate the three top level cells

-rot ( n1 n2 n3 -- n3 n1 n2) reverse rotate the three top level cells equivalent to rotate twice but faster

sp@ (  -- addr ) current data stack pointer

sp! ( addr -- i*x) set data stack pointer to addr

sp0 ( -- addr) start address of the data stack

sp ( -- addr) address of user variable to store top-of-stack for inactive tasks

depth ( -- n ) number of single-cell values contained in the data stack before n was placed on the stack.


Return Stack: (9 words)
-------------
Defined in assembly core:

r>     ( -- n ) (R: n -- ) move top of return stack to top of parameter stack

r>drop ( -- ) (R: n -- ) drop top of return stack : inline

dup>r  ( n -- n ) (R: -- n ) copy TOS to TOR

>r     ( n -- ) (R: -- n ) move TOS to TOR

r@     ( -- x) (R: n -- n ) use TOR as address to fetch content from ram

r>r+   ( -- n) (R: n -- n+1 ) fetch content of TOR and then increment TOR by 1

rp@    (  -- n) current return stack pointer address

rp!    ( addr  -- ) (R: -- x*y) set return stack pointer

rp0    ( -- addr) start address of return stack in ram


Operators: (50 words)
----------
Defined in assembly core:

compare:

<>
0=
=
<
>
0<
0>
u<
u>
u<=
u>=
min
max
within


arithmetics:
0: ( n -- 0 ) replaces TOS with 0
0
1
2
10
true
0?
?0?
-
+
/
/mod
u/mod
um/mod
*
m*
*/
*/mod
invert
swnib
2/
2*
1+
1-
2+
2-
><
0~
~0
w_
btow
<<
>>
negate
abs

logic:

and
or
xor

Memory: (34 words)
-------

cmove
c>
c!   ( c a-addr -- ) store a single byte to RAM address
c@   ( a-addr - c1 ) fetch a single byte from RAM address
+c!  ( n a-addr -- ) add n to content of byte RAM address a-addr
1+c! ( a-addr -- ) add 1 to content of byte RAM address a-addr
@    ( a-addr -- n ) read 1 cell from RAM address
!    ( n addr -- ) write n to RAM memory at addr, low byte first
+!   ( n a-addr -- ) add n to content of word RAM address a-addr
1+!  ( a-addr -- ) add 1 to content of word RAM address a-addr
@u   ( index -- n ) read 1 cell from user RAM address + index
!u   ( n index -- ) write n to RAM memory at user RAM addr + index, low byte first
!e   ( n e-addr -- ) write n (2bytes) to eeprom address
@e   ( e-addr - n) read 1 cell from eeprom
!i   ( n f-addr -- ) writes n to flash memory 
@i   ( f-addr -- n1 ) read 1 cell from flash
a@   ( -- n ) Read RAM memory pointed to by register A 
a@i  ( -- n ) Read program memory pointed to by register
ac@  ( -- n ) Read a byte from ram pointed to by register A
a!   ( n -- ) Write memory pointed to by register A 
ac!  ( n -- ) Write char memory pointed to by register A
na!  ( n offs -- ) Write TOS to memory pointed to by register A plus offset
a+   ( -- ) update register A with post increment from last memory operation
>a   ( n -- ) A: n Move TOS to A register
>b   ( n -- ) B: n Move TOS to B register 
:a   ( n -- n ) A: n copy TOS to A register
:b   ( n -- n ) B: n copy TOS to B register
nip>a ( n1 n2 -- n2 ) A: n1 Remove next on stack and write to A register
nip>b ( n1 n2 -- n2 ) B: n1 Remove next on stack and write to B register
a    ( -- n ) put the A register on TOS
b    ( -- n ) put the B register on TOS
fill
itoi
@e[]
!e[]
ee>ram
compare
icompare

Environment: (7 words)
------------

/pad
/hold
fname
version
cpu
mcu-info
/user


Numeric/Character IO: (31 words)
---------------------

u.
base
bin
decimal
hex
bl
emit
emit?
key
key?
hld
hold
<#
#
#>
#s
sign
.
.r
digit?
itype
type
cr
space
spaces

accept
refill
char
number
praefix
>number



String: (7 words)
-------

cskip
cscan
parse
/$
$l
srcin
parse-name


Exceptions: (4 words)
-----------

handle
catch
abort
throw

ASM: (13 words)
----

mask!
P,b,
rd,k,
ldi,
ret,
cbi,
sbi,
sbic,
sbis,
rjmp
rjmpc
int+
int-

Tools: (14 words)
------

.s ( -- )  stack dump - prints contents of stack to output device
words ( -- ) prints a list of all (visible) words in the dictionary
find-name ( addr len --  0 | xt -1 | xt 1 ) search wordlists for the name from string addr/len
?stack
ver
unused
dbg-
dbg+
init-user
.hex4
dmp
rbs
rbc
rb?
r?
fence
forget
